# modis_geometric_correction
The function of this repository is reading the *.hdf data of MODIS and correct this data about georeference  and save the RGB color image.

MODIS数据分析与介绍：

MODIS-1B数据是MODIS 44种系列数据产品中的一种，产品编号为MOD02(Terra-MODIS)/MYD02(Aqua-MODIS)；是经过仪器标定的数据产品，但是没有经过大气校正（envi打开的标准1B数据，直接显示为表观反射率（TOA reflectance））；是包含有地理坐标产品的数据，但是“科学数据”和“地理数据”还没有连接，直接显示时，边缘存在“蝴蝶结”（Bow-tie）现象；MODIS-1B数据采用层次数据模型（HDF）或其对地观测扩展（HDF-EOS），这些模型有不同版本，受不同软件支持。3个科学数据（Earth View，Science Data Set）+1类工程数据（OBC）:

MOD02QKM MYD02QKM 校正过的 250 米分辨率的对地观测数据。

MOD02HKM MYD02HKM 校正过的 500 米分辨率的对地观测数据，包括25米重采样为500 米分辨率数据。

MOD021KM MYD021KM 校正过的1 公里分辨率的对地观测数据，包括250米和500 米重采样为1 公里分辨率的数据。

MOD02OBC MYD02OBC 星上校正器（OBC）和工程数据。

其中，3类科学数据与36个波段的对应关系如下表：除1km的其中几个波段外，其余全部为反射太阳波段。在夜间模式下，这些反射太阳波段都没有数据（只有填充数值）MODIS Level 1B产品波段分组。

**表****1 MODIS****波段数据介绍：**

| Cryptic  name   | 空间分辨率 | 波段数 | 波段          |
| --------------- | ---------- | ------ | ------------- |
| EV_250_RefSB    | 250  m     | 2      | 1,  2         |
| EV_500_RefSB    | 500  m     | 5      | 3,4,5,6,7     |
| EV_1KM_RefSB    | 1  km      | 15     | 8-19,  26     |
| EV_1KM_Emissive | 1  km      | 16     | 20-25,  27-36 |

表中前三行（子数据集）为反射太阳波段，最后一行（子数据集）为热辐射波段。

打开1个MODIS 1B 数据块（granule）时，出现8个文件。按照文件后缀，其中4个为HDF文件，4个为met文件（元数据），他们分别是4组文件。按照文件内容，分为3组科学数据（地球观测数据，EV），1组定标数据（OBC数据）。

250m分辨率的QKM文件包含11个数据层，包括地理定位信息（经度和纬度2 层）和科学信息（Scaled Integer反射值；不确定性指数）等。

打开MODIS02级1km数据，其中250米和500米的波段经过重采样为1km加入这个数据集中。ENVI根据各个波段的中心波长信息定标为三个类型数据：反射率数据（Reflectance）、辐射亮度值数据（Radiance）和发射率数据（Emissive）。其中反射率和发射率为0~1无单位值，辐射亮度值单位是：W/m2/μm/sr。

本实验利用GDAL库对MODIS L1B数据进行几何校正，并对其1，4，3，波段合成RGB真彩色数据保存显示。

**（一）** **Python代码与注释详解：**

**MODIS-L1B数据几何校正代码：**



```python
'''
For:Geometric correction map projection.

Time:10/19/2021
Author:Guo Jiaxiang
Email：guojiaxiang0820@gmail.com
GitHubBlog:https://github.com/guojx0820
'''

import os
from osgeo import gdal, osr


# Define a function which is geometricing correction of remote sensing images.
def modis_geo(input_file, geo_file, geo_name, output_file, geo_bound, x_res, y_res):
    # Read a *.hdf file using Open() function of GDAL lib
    dataset = gdal.Open(input_file)
    # Get the subdatasets' name from the dataset using the function GetSubDatasets() of GDAL lib.
    subdatasets = dataset.GetSubDatasets()
    # Set dataset and target data's order of 0 and -1.
    total_dataset_ord = 0
    tar_dateset_ord = -1
    # Print all the subdatesets' name in the dataset.
    for subdataset in subdatasets:
        print(subdataset)
        sub_name = subdataset[0]
        #
        if sub_name.endswith(geo_name):
            tar_dateset_ord = total_dataset_ord
        total_dataset_ord += 1
    # Batch processing the date of the subdataset files.
    if tar_dateset_ord != -1:
        target_dataset = dataset.GetSubDatasets()[tar_dateset_ord][0]
        # Reverve search file path using the function of os lib.
        '''
        os.path.splittext() is more used to search for file path and file extension. 
        These two combine to form a complete path. 
        If we use the normal split() function to obtain the extension, the efficiency is very low.
        '''
        # VRT file is a virtual file format generated by GDAL function,
        # which is used for geometric correction of images.
        vrt_search = os.path.splitext(input_file)[0] + '.vrt'
        vrt_output = gdal.Translate(vrt_search, target_dataset, \
                                    format='vrt', unscale='true')
        # Creating a spatial reference coordinate system, wgs1984
        srs = osr.SpatialReference()
        srs.ImportFromEPSG(4326)
        # Calling the function Warp() of GDAL to correct the images of *.hdf dataset of MODIS.
        geo_cor_data = gdal.Warp(output_file, vrt_output, multithread=True, outputBounds=geo_bound,
                                 format='GTiff', geoloc=True, dstSRS=srs,
                                 xRes=x_res, yRes=y_res, dstNodata=0.0, outputType=gdal.GDT_Float32)
        print('The geometric correction of {} has finished!'.format(input_file))
        os.remove(vrt_search)
    else:
        print('{} has no the target dataset.'.format(input_file))
    return geo_file, geo_cor_data


if __name__ == '__main__':
    # Set the format and path of the dataset with batch processing.
    file_postfix = '.hdf'
    input_directory = '/Users/leo/Desktop/Data/OriginalData/'
    output_directory = '/Users/leo/Desktop/Data/Results/'
    if not os.path.exists(output_directory):
        os.mkdir(output_directory)
    file_list = os.listdir(input_directory)
    for i in file_list:
        if i.endswith(file_postfix):
            # Output file name.
            file_name = input_directory + i
            output_file12 = output_directory + '20190817-b12' + '_geo.tiff'
            output_file34567 = output_directory + '20190817-b34567' + '_geo.tiff'
            # Target subdataset name.
            subdataset_name12 = 'MODIS_SWATH_Type_L1B:EV_250_Aggr1km_RefSB'
            subdataset_name34567 = 'MODIS_SWATH_Type_L1B:EV_500_Aggr1km_RefSB'
            geo_bound = None
            # Set the pixel resolution of the output (x and y direction).
            # Here we use latitude and longitude units.
            x_res = 0.01
            y_res = 0.01
            # Executing the modis_geo() function.
            execute = modis_geo(file_name, file_name, subdataset_name12, output_file12, geo_bound, x_res, y_res)
            execute = modis_geo(file_name, file_name, subdataset_name34567, output_file34567, geo_bound, x_res, y_res)
```

 

**MODIS-L1B数据几何校正后真彩色图像合成与保存代码：**

 

```python
'''
For:Combine MODIS three channel data to generate true color image and save the image.

Time:10/19/2021
Author:Guo Jiaxiang
Email：guojiaxiang0820@gmail.com
GitHubBlog:https://github.com/guojx0820
'''

from osgeo import gdal
import numpy as np
import matplotlib.pyplot as plt

# Set a function which read image file
def read_img(filename):
    # Opening dateset file.
    dataset = gdal.Open(filename)
    # Number of columns in grid matrix.
    width = dataset.RasterXSize
    # Number of rows of grid matrix.
    height = dataset.RasterYSize
    # Set a affine matrix.
    geo_trans = dataset.GetGeoTransform()
    # Set the projection information.
    proj = dataset.GetProjection()
    # Writing the data into an array corresponding to the grid matrix.
    data = dataset.ReadAsArray(0, 0, width, height).astype(np.float)
    # print(proj, geo_trans, data)
    # Close object:dataset
    del dataset
    # Return multi-values.
    return proj, geo_trans, data, height, width


# Set a function which write image file
def write_img(filename, proj, geotrans, data):
    # Determine the data type of raster data:int8,int16,uint16,float32.
    if 'int8' in data.dtype.name:
        datatype = gdal.GDT_Byte
    elif 'int16' in data.dtype.name:
        datatype = gdal.GDT_UInt16
    else:
        datatype = gdal.GDT_Float32

    # Detect the array dimension.
    if len(data.shape) == 3:
        # Order of data：im_bands, im_height, im_width.
        bands, height, width = data.shape
    else:
        im_bands, (height, width) = 1, data.shape

    # Calling GetDriverByName() function of GDAL lib.
    driver = gdal.GetDriverByName("GTiff")
    dataset = driver.Create(filename, width, height, bands, datatype)
    # Write affine transformation parameters.
    dataset.SetGeoTransform(geotrans)
    # Write projection
    dataset.SetProjection(proj)

    if bands == 1:
        # Write array data
        dataset.GetRasterBand(1).WriteArray(data)
    else:
        for i in range(bands):
            dataset.GetRasterBand(i + 1).WriteArray(data[i])
    # Close object:dataset
    del dataset
    return filename

# Set a function which stretch the image by linear.
def five_perc_linear(gray, maxout, minout):
    # Get the corresponding gray level at 95% histogram.
    high_value = np.percentile(gray, 95)
    low_value = np.percentile(gray, 5)
    truncated_gray = np.clip(gray, a_min=low_value, a_max=high_value)
    # Linear stretching.
    processed_gray = ((truncated_gray - low_value) / (high_value - low_value)) * (maxout - minout)
    return processed_gray

# Set a function which save the image file.
def save_RGB_img(ds_2bands, ds_5bands):
    max_out = 255
    min_out = 0
    # Take out bands 1, 4, 3 and 3 in MODIS data,
    # corresponding to RGB three bands respectively.
    R = ds_2bands[0]
    G = ds_5bands[1]
    B = ds_5bands[0]
    r = five_perc_linear(R, max_out, min_out)
    g = five_perc_linear(G, max_out, min_out)
    b = five_perc_linear(B, max_out, min_out)
    # Stored in the same array.
    data = np.array((r, g, b), dtype=r.dtype)
    # Write as 3-band true color data：Red，Green，Blue.
    write_img(output_file, proj, geotrans, data)


if __name__ == '__main__':
    # Set the path of the input and output files with the *.tiff postfix.
    # Set the output file name of ture color image.
    file_path2b = '/Users/leo/Desktop/Data/Results/20190817-b12_geo.tiff'
    file_path5b = '/Users/leo/Desktop/Data/Results/20190817-b34567_geo.tiff'
    output_file = '/Users/leo/Desktop/Data/Results/RGB_color5.tiff'
    # Calling the read_img() to read the 2 datasets.
    proj, geotrans, values2b, row, col = read_img(file_path2b)
    proj, geotrans, values5b, row, col = read_img(file_path5b)
    # Calling the save_RGB_img() function to save the ture color image.
    img = save_RGB_img(values2b, values5b)
    print(values2b[0], values5b[1], values5b[0])

```

 



 

**（二）** **结果与总结：**

1、结果展示：

![img](file:////Users/leo/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image002.jpg)

**图****1****我国南海地区****MODIS L1B2019****年****8****月****17****日未经几何校正数据展示**

![img](file:////Users/leo/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image003.jpg)

**图****2****我国南海地区****MODIS L1B****数据****2019****年****8****月****17****日几何校正真彩色结果**

 

![img](file:////Users/leo/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image005.jpg)![img](file:////Users/leo/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image007.jpg)

**图****3** **几种假彩色数据显示（左图为彩红外影像（标准假彩色））**

![img](file:////Users/leo/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image009.jpg)![img](file:////Users/leo/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image011.jpg)

**图****4** **几何校正结果检验**

3、结论与分析

由于没有精度验证数据，所以利用地理位置精准的矢量数据与MYD03经纬度数据几何校正结果进行精度检验，结果显示，利用GDAL进行MODIS L1B数据的几何校正精度较高，满足一定的科研与实验要求。